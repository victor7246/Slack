// copied from https://developers.google.com/speed/webp/faq#server-side_content_negotiation_via_accept_headers

// check_webp_feature:
//   'feature' can be one of 'lossy', 'lossless', 'alpha' or 'animation'.
//   'callback(feature, result)' will be passed back the detection result (in an asynchronous way!)
function check_webp_feature(feature, callback) {
    const kTestImages = {
        lossy: "UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",
        lossless: "UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==",
        alpha: "UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==",
        animation: "UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA"
    };
    let img = new Image();
    img.onload = function() {
        let result = (img.width > 0) && (img.height > 0);
        callback(feature, result);
    };
    img.onerror = function() {
        callback(feature, false);
    };
    img.src = "data:image/webp;base64," + kTestImages[feature];
}

let FeatureDetection = {
  webp(feature, cb) {
    check_webp_feature(feature, cb);
  }
}

// Start: Adapted from https://github.com/MoOx/color-convert
// MIT : https://github.com/MoOx/color-convert/blob/master/LICENSE
// Copyright (c) 2011 Heather Arthur <fayearthur@gmail.com>

function rgb2xyz(rgb) {
    let r = rgb[0] / 255,
        g = rgb[1] / 255,
        b = rgb[2] / 255;

    // assume sRGB
    r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
    g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
    b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

    let x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
    let y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
    let z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

    return [x * 100, y * 100, z * 100];
}

function rgb2lab(rgb) {
    let xyz = rgb2xyz(rgb),
        x = xyz[0],
        y = xyz[1],
        z = xyz[2],
        l, a, b;

    x /= 95.047;
    y /= 100;
    z /= 108.883;

    x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
    y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
    z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

    l = (116 * y) - 16;
    a = 500 * (x - y);
    b = 200 * (y - z);

    return [l, a, b];
}

// End : Adapted from https://github.com/MoOx/color-convert

function hexToRgb(hex) {
    let shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, function(m, r, g, b) {
        return r + r + g + g + b + b;
    });

    let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if (!result) {
        console.log('Could not parse color', hex);
        return [0, 0, 0];
    }
    return [
        parseInt(result[1], 16),
        parseInt(result[2], 16),
        parseInt(result[3], 16)
    ];
}

const TEXT_WHITE = '#fff';
const TEXT_BLACK = '#000';
const BG_RS = ['#ed154f', '#ED1651', '#C82254', '#A62A57', '#842F59', '#842F59', '#35355C', '#231F20'];
const L_TH = 64;

let ColorTools = {
    randomTheme() {
        return BG_RS[Math.floor(Math.random() * BG_RS.length)];
    },

    textColorFor(c) {
        if (typeof c === 'string' || c instanceof String) {
            c = hexToRgb(c);
        }
        let lab = rgb2lab(c);
        if (lab[0] < L_TH) {
            return TEXT_WHITE;
        }
        return TEXT_BLACK;
    },

    lightnessSort() {
        let lab = colors.map(function(c) {
            let a = c;
            if (!Array.isArray(c)) {
                a = hexToRgb(c);
            }

            return [rgb2lab(a), c];
        });

        let sort = lab.sort(function(a, b) {
            if (a[0][0] < b[0][0]) return -1;
            if (a[0][0] > b[0][0]) return -1;
            return 0;
        });

        return sort.map(function(a) {
            return a[1];
        });
    },

    themes: BG_RS
};

let Lang = {
    localShortMonths(lang) {
        if (lang === undefined) {
            lang = navigator.language;
        }
        let formatter = null;

        if (window.Intl !== undefined) {
            formatter = new Intl.DateTimeFormat(lang, {
                month: 'short',
                timeZone: 'UTC'
            });
        } else {
            formatter = {
                format: function(date) {
                    return date.toUTCString().split(' ')[2]
                }
            }
        }
        return Array.apply(null, Array(12)).map(function(_, i) {
            return formatter.format(new Date(Date.UTC(2014, i, 7)));
        });
    },
    localShortWeekday(lang) {
        if (lang === undefined) {
            lang = navigator.language;
        }
        let formatter = null;

        if (window.Intl !== undefined) {
            formatter = new Intl.DateTimeFormat(lang, {
                weekday: 'short',
                timeZone: 'UTC'
            });
        } else {
            formatter = {
                format: function(date) {
                    return date.toUTCString().split(' ')[0].substring(0, 3)
                }
            }
        }
        return Array.apply(null, Array(7)).map(function(_, i) {
            return formatter.format(new Date(Date.UTC(2014, 1, i + 2)));
        });
    }
};

const SCROLL_DURATION = 200;

// Adapted from https://coderwall.com/p/hujlhg/smooth-scrolling-without-jquery
function smooth_scroll_to(element, target, duration) {
    target = Math.round(target);
    duration = Math.round(duration);
    if (duration < 0) {
        return Promise.reject('bad duration');
    }
    if (duration === 0) {
        element.scrollTop = target;
        return Promise.resolve('no-duration');
    }

    let start_time = Date.now();
    let end_time = start_time + duration;

    let start_top = element.scrollTop;
    let distance = target - start_top;

    // based on http://en.wikipedia.org/wiki/Smoothstep
    let smooth_step = function(start, end, point) {
        if (point <= start) {
            return 0;
        }
        if (point >= end) {
            return 1;
        }
        let x = (point - start) / (end - start); // interpolation
        return x * x * (3 - 2 * x);
    }

    return new Promise(function(resolve, reject) {
        // This is to keep track of where the element's scrollTop is
        // supposed to be, based on what we're doing
        let previous_top = element.scrollTop;

        let timer = null;
        // This is like a think function from a game loop
        let scroll_frame = function() {
            /*
            // This logic is too fragile
            if(element.scrollTop != previous_top) {
                window.clearInterval(timer);
                reject('interrupted');
                return;
            }
            */
            // set the scrollTop for this frame
            let now = Date.now();
            let point = smooth_step(start_time, end_time, now);
            let frameTop = Math.round(start_top + (distance * point));
            element.scrollTop = frameTop;

            // check if we're done!
            if (now >= end_time) {
                window.clearInterval(timer);
                resolve('done');
                return;
            }

            // If we were supposed to scroll but didn't, then we
            // probably hit the limit, so consider it done; not
            // interrupted.
            if (element.scrollTop === previous_top && element.scrollTop !== frameTop) {
                window.clearInterval(timer);
                resolve('limit');
                return;
            }
            previous_top = element.scrollTop;
        }

        // boostrap the animation process
        timer = setInterval(scroll_frame, 10);
    });
}

function clickFor(to, offset) {
    return function(evt) {
        let target = document.getElementById(to);
        if (target === undefined) {
            return true;
        }
        offset = offset || 0;
        let delta = getAbsoluteBoundingRect(target).top + offset;
        smooth_scroll_to(document.body, delta, SCROLL_DURATION).catch(function(e) {
            console.error(e);
        });
        evt.preventDefault();
        return false;
    }
}

let scrollNodes = [];

function throttle(type, name, obj) {
    obj = obj || window;
    let running = false;
    let func = function() {
        if (running) {
            return;
        }
        running = true;
        requestAnimationFrame(function() {
            obj.dispatchEvent(new CustomEvent(name));
            running = false;
        });
    };
    obj.addEventListener(type, func);
}

function onScroll() {
    let pos = window.scrollY;
    scrollNodes.forEach(function(params) {
        let node = params[0];
        let current = params[1];
        let cls = params[2];
        let extents = params[4];

        let state = false;
        for (let i = 0; i < extents.length; i++) {
            let extent = extents[i];
            state = (pos > extent.start && pos < extent.end);
            if (state) {
                break;
            }
        }

        if (state === current) {
            return;
        }
        params[1] = state;
        if (state) {
            node.classList.add(cls);
        } else {
            node.classList.remove(cls);
        }
    });
}

function getAbsoluteBoundingRect(el) {
    let doc = document,
        win = window,
        body = doc.body,

        // pageXOffset and pageYOffset work everywhere except IE <9.
        offsetX = win.pageXOffset !== undefined ? win.pageXOffset :
        (doc.documentElement || body.parentNode || body).scrollLeft,
        offsetY = win.pageYOffset !== undefined ? win.pageYOffset :
        (doc.documentElement || body.parentNode || body).scrollTop,

        rect = el.getBoundingClientRect();

    if (el !== body) {
        let parent = el.parentNode;

        // The element's rect will be affected by the scroll positions of
        // *all* of its scrollable parents, not just the window, so we have
        // to walk up the tree and collect every scroll offset. Good times.
        while (parent !== body) {
            offsetX += parent.scrollLeft;
            offsetY += parent.scrollTop;
            parent = parent.parentNode;
        }
    }

    return {
        bottom: rect.bottom + offsetY,
        height: rect.height,
        left: rect.left + offsetX,
        right: rect.right + offsetX,
        top: rect.top + offsetY,
        width: rect.width
    };
}

function updateRegions() {
    scrollNodes.forEach(function(params) {
        let target = params[0].getBoundingClientRect();
        let overlap = params[3];

        let nodes = document.querySelectorAll(overlap);
        let all = [];
        for (let i = 0; i < nodes.length; i++) {
            let node = nodes[i];
            let ext = getAbsoluteBoundingRect(node);
            all.push({
                start: ext.top - target.height,
                end: ext.bottom
            });
        }
        params[4] = all;
    });
}

let Scroll = {
    initSmooth(selector, offset) {
        let nodes = document.querySelectorAll(selector);
        for (let i = 0; i < nodes.length; i++) {
            let node = nodes[i];
            let href = node.attributes.href;
            if (href === undefined || href.length === 0) {
                continue;
            }
            let to = href.nodeValue.toString();
            if (to.substr(0, 1) !== '#') {
                continue;
            }

            node.addEventListener('click', clickFor(to.substr(1), offset), false);
        }
    },
    toggleClass(selector, cls, overlap) {
        let nodes = document.querySelectorAll(selector);
        if (nodes.length > 0) {
            window.addEventListener('optimizedResize', updateRegions);
            window.addEventListener('optimizedScroll', onScroll);
        }
        for (let i = 0; i < nodes.length; i++) {
            let node = nodes[i];
            let param = [node, null, cls, overlap, []];

            // check for this node
            let found = false;
            for (let ii = 0; i < scrollNodes.length; i++) {
                if (scrollNodes[ii][0] == node) {
                    scrollNodes[ii] = param;
                    found = true;
                    break;
                }
            }
            if (!found) {
                scrollNodes.push(param);
            }
        }
        updateRegions();
        onScroll();
    },
    updateRegions: updateRegions
};

throttle('scroll', 'optimizedScroll');
throttle('resize', 'optimizedResize');

var Timing = {
  now() {
    var performance = window.performance;
    if (performance === undefined) {
      this.now = function() {
        return new Date().getTime();
      }
    } else {
      if (performance.now) {
        this.now = function() { return performance.now();}
      } else if (performance.webkitNow) {
        this.now = function() { return performance.webkitNow();}
      } else if (performance.msNow) {
        this.now = function() { return performance.msNow();}
      } else if (performance.oNow) {
        this.now = function() { return performance.oNow();}
      } else if (performance.mozNow) {
        this.now = function() { return performance.mozNow();}
      } else {
        throw new Error('unknown window.performance impl');
      }
    }

    return this.now();
  }
};

class DB {
    constructor(treo, max = 5) {
        this.treo = treo;
        this.tm = {};
        this.count = 0;
        this.outstanding = [];
        this.runningTotal = 0;
        this.puts = 0;
        this.max = max
        if (max) {
            this.max = max;
        }
    }

    countQueue() {
        return this.puts;
    }

    countTransactionsQueue() {
        return this.outstanding.length;
    }

    countTransactions() {
        return this.count;
    }

    runningTransactionTotal() {
        return this.runningTotal;
    }

    shiftq(store, q, name, on) {
        if (on === undefined) {
            on = 1;
        }
        let self = this;
        let e = q.shift();
        if (e) {
            let req = store.put(e.v, e.k);
            this.puts = this.puts - 1;
            req.onsuccess = function() {
                // Technically the transaction could still be aborted/fail so slightly wrong
                e.r();
                self.shiftq(store, q, name, (on + 1));
            };
            req.onerror = function(event) {
                e.j(event);
            };
        } else {
            // done, transaction will close
            // console.log('Drained', name, 'on', on);
            this.tm[name] = null;
        }
    }

    gate(cb) {
        let self = this;

        function invoke() {
            let called = false;
            self.count = self.count + 1;
            try {
                self.runningTotal = self.runningTotal + 1;
                cb(function() {
                    if (!called) {
                        called = true;
                        self.count = self.count - 1;
                    }
                    let next = self.outstanding.shift();
                    if (next) {
                        self.gate(next);
                    }
                });
            } catch (e) {
                if (!called) {
                    called = true;
                    self.count = self.count - 1;
                }
                throw e;
            }
        }

        if (this.count >= this.max) {
            // console.log(this.count, 'transactions reached, moved to the q');
            this.outstanding.push(cb);
        } else {
            invoke();
        }
    }

    put(store, val, optionalKey) {
        let self = this;
        let treo = this.treo;
        let tm = this.tm;
        let q = tm[store];
        this.puts = this.puts + 1;
        return new Promise(function(resolve, reject) {
            let entry = {
                v: val,
                r: resolve,
                j: reject,
                k: optionalKey
            };
            if (q == null) {
                q = [entry];
                tm[store] = q;

                self.gate(function(release) {
                    treo.transaction('readwrite', [store], function(err, tr) {
                        if (err) {
                            release();
                            q.forEach(function(e) {
                                e.j();
                            });
                            return;
                        }

                        tr.oncomplete = function() {
                            release();
                            tm[store] = null;
                        };

                        tr.onerror = function(event) {
                            q.forEach(function(e) {
                                e.j();
                            });
                            release();
                            tm[store] = null;
                        };

                        // start the drain
                        self.shiftq(tr.objectStore(store), q, store);
                    });
                });
            } else {
                q.push(entry);
            }
        });
    }
}

let TreoWriter = {
    wrap(treo, max) {
        return new DB(treo, max);
    }
};

let style = document.createElement("style");
document.head.appendChild(style);
let sheet = style.sheet;

function updateRange(input, index) {
    let min = input.min || 0;
    let max = input.max || 100;

    let v = Math.ceil(((input.value - min) / (max - min)) * 100);
    try {
        sheet.deleteRule(index);
    } catch (e) {}
    sheet.addRule('input[type=range].rs-index-' + index + '::-webkit-slider-runnable-track', 'background-size:' + v + '% 100%', index);
}

let Sliders = {
    initAllRanges() {
        let r = document.querySelectorAll('input[type=range]');
        for (let i = 0; i < r.length; i++) {
            let input = r[i];

            input.className += " rs-index-" + i;
            updateRange(input, i);
            (function(idx) {
                input.addEventListener('input', function() {
                    updateRange(this, idx);
                });
            })(i);
        }
    },

    setValue(control, value) {
        control.value = value;
        let r = document.querySelectorAll('input[type=range]');
        for (let i = 0; i < r.length; i++) {
            if (r[i] === control) {
                updateRange(control, i);
            }
        }
    }
};

let StyleSwitcher = {
    use(title) {
        let themes = document.getElementsByTagName('link');
        for (let idx = 0; idx < themes.length; idx++) {
            let theme = themes[idx];

            if ((theme.rel.indexOf('stylesheet') != -1) && theme.title) {
                theme.disabled = true;
                if (theme.title == title) {
                    theme.disabled = false;
                }
            }
        }
    }
}

// Smooth some data with a given window size.
function smooth(d, w) {
    let result = [];
    for (let i = 0, l = d.length; i < l; ++i) {
        let mn = Math.max(0, i - 5 * w),
            mx = Math.min(d.length - 1, i + 5 * w),
            s = 0.0;
        result[i] = 0.0;
        for (let j = mn; j < mx; ++j) {
            let wd = Math.exp(-0.5 * (i - j) * (i - j) / w / w);
            result[i] += wd * d[j];
            s += wd;
        }
        result[i] /= s;
    }
    return result;
}

let Xkcd = {
	wiggle(perturbation, magnitude, fx, fy) {
		if (perturbation === undefined) {
			perturbation = 0.93;
		}

        if (magnitude === undefined) {
			magnitude = 0.003;
		}

        if (fx === undefined) {
			fx = 500;
		}

        if (fy === undefined) {
			fy = 300;
		}

        // XKCD-style line interpolation. Roughly based on:
        // jakevdp.github.com/blog/2012/10/07/xkcd-style-plots-in-matplotlib
        return function (points) {
            // Scale the data.
            let scaled = points.map(function (p) {
                return [p[0] / fx, p[1] / fy];
            });

            // Compute the distance along the path using a map-reduce.
            let dists = scaled.map(function (d, i) {
                if (i == 0) return 0.0;
                let dx = d[0] - scaled[i - 1][0],
                    dy = d[1] - scaled[i - 1][1];
                return Math.sqrt(dx * dx + dy * dy);
            }),
                dist = dists.reduce(function (curr, d) { return d + curr; }, 0.0);

            // Choose the number of interpolation points based on this distance.
            let N = Math.round(200 * dist);

            // Re-sample the line.
            let resampled = [];
            dists.map(function (d, i) {
                if (i == 0) return;
                let n = Math.max(3, Math.round(d / dist * N)),
                    spline = d3.interpolate(scaled[i - 1][1], scaled[i][1]),
                    delta = (scaled[i][0] - scaled[i - 1][0]) / (n - 1);
                for (let j = 0, x = scaled[i - 1][0]; j < n; ++j, x += delta)
                    resampled.push([x, spline(j / (n - 1))]);
            });

            // Compute the gradients.
            let gradients = resampled.map(function (a, i, d) {
                if (i == 0) return [d[1][0] - d[0][0], d[1][1] - d[0][1]];
                if (i == resampled.length - 1)
                    return [d[i][0] - d[i - 1][0], d[i][1] - d[i - 1][1]];
                return [0.5 * (d[i + 1][0] - d[i - 1][0]),
                        0.5 * (d[i + 1][1] - d[i - 1][1])];
            });

            // Normalize the gradient vectors to be unit vectors.
            gradients = gradients.map(function (d) {
                let len = Math.sqrt(d[0] * d[0] + d[1] * d[1]);
                if (len === 0) return [0, 0];
                return [d[0] / len, d[1] / len];
            });

            // Generate some perturbations.
            let perturbations = smooth(resampled.map(d3.random.normal(0.0, perturbation)), 3);

            // Add in the perturbations and re-scale the re-sampled curve.
            let result = resampled.map(function (d, i) {
                let p = perturbations[i],
                    g = gradients[i];

                return [((d[0] + magnitude * g[1] * p) * fx).toFixed(6),
                        ((d[1] - magnitude * g[0] * p) * fy).toFixed(6)];
            });

            return result.join("L");
        }
	}
};

const disableSelectionStyle = `
  * {
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
  }
`;

function cssDisableSelection() {
  var node = document.createElement('style');
  node.innerHTML = disableSelectionStyle;
  document.body.appendChild(node);
}

export { FeatureDetection, ColorTools, Lang, Scroll, Timing, TreoWriter, Sliders, StyleSwitcher, Xkcd, cssDisableSelection };