(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.RedsiftCore = global.RedsiftCore || {})));
}(this, function (exports) {

  // copied from https://developers.google.com/speed/webp/faq#server-side_content_negotiation_via_accept_headers

  // check_webp_feature:
  //   'feature' can be one of 'lossy', 'lossless', 'alpha' or 'animation'.
  //   'callback(feature, result)' will be passed back the detection result (in an asynchronous way!)
  function check_webp_feature(feature, callback) {
      var kTestImages = {
          lossy: "UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",
          lossless: "UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==",
          alpha: "UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==",
          animation: "UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA"
      };
      var img = new Image();
      img.onload = function() {
          var result = (img.width > 0) && (img.height > 0);
          callback(feature, result);
      };
      img.onerror = function() {
          callback(feature, false);
      };
      img.src = "data:image/webp;base64," + kTestImages[feature];
  }

  var FeatureDetection = {
    webp: function webp(feature, cb) {
      check_webp_feature(feature, cb);
    }
  }

  // Start: Adapted from https://github.com/MoOx/color-convert
  // MIT : https://github.com/MoOx/color-convert/blob/master/LICENSE
  // Copyright (c) 2011 Heather Arthur <fayearthur@gmail.com>

  function rgb2xyz(rgb) {
      var r = rgb[0] / 255,
          g = rgb[1] / 255,
          b = rgb[2] / 255;

      // assume sRGB
      r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
      g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
      b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

      var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
      var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
      var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

      return [x * 100, y * 100, z * 100];
  }

  function rgb2lab(rgb) {
      var xyz = rgb2xyz(rgb),
          x = xyz[0],
          y = xyz[1],
          z = xyz[2],
          l, a, b;

      x /= 95.047;
      y /= 100;
      z /= 108.883;

      x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
      y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
      z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

      l = (116 * y) - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);

      return [l, a, b];
  }

  // End : Adapted from https://github.com/MoOx/color-convert

  function hexToRgb(hex) {
      var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
      hex = hex.replace(shorthandRegex, function(m, r, g, b) {
          return r + r + g + g + b + b;
      });

      var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      if (!result) {
          console.log('Could not parse color', hex);
          return [0, 0, 0];
      }
      return [
          parseInt(result[1], 16),
          parseInt(result[2], 16),
          parseInt(result[3], 16)
      ];
  }

  var TEXT_WHITE = '#fff';
  var TEXT_BLACK = '#000';
  var BG_RS = ['#ed154f', '#ED1651', '#C82254', '#A62A57', '#842F59', '#842F59', '#35355C', '#231F20'];
  var L_TH = 64;

  var ColorTools = {
      randomTheme: function randomTheme() {
          return BG_RS[Math.floor(Math.random() * BG_RS.length)];
      },

      textColorFor: function textColorFor(c) {
          if (typeof c === 'string' || c instanceof String) {
              c = hexToRgb(c);
          }
          var lab = rgb2lab(c);
          if (lab[0] < L_TH) {
              return TEXT_WHITE;
          }
          return TEXT_BLACK;
      },

      lightnessSort: function lightnessSort() {
          var lab = colors.map(function(c) {
              var a = c;
              if (!Array.isArray(c)) {
                  a = hexToRgb(c);
              }

              return [rgb2lab(a), c];
          });

          var sort = lab.sort(function(a, b) {
              if (a[0][0] < b[0][0]) return -1;
              if (a[0][0] > b[0][0]) return -1;
              return 0;
          });

          return sort.map(function(a) {
              return a[1];
          });
      },

      themes: BG_RS
  };

  var Lang = {
      localShortMonths: function localShortMonths(lang) {
          if (lang === undefined) {
              lang = navigator.language;
          }
          var formatter = null;

          if (window.Intl !== undefined) {
              formatter = new Intl.DateTimeFormat(lang, {
                  month: 'short',
                  timeZone: 'UTC'
              });
          } else {
              formatter = {
                  format: function(date) {
                      return date.toUTCString().split(' ')[2]
                  }
              }
          }
          return Array.apply(null, Array(12)).map(function(_, i) {
              return formatter.format(new Date(Date.UTC(2014, i, 7)));
          });
      },
      localShortWeekday: function localShortWeekday(lang) {
          if (lang === undefined) {
              lang = navigator.language;
          }
          var formatter = null;

          if (window.Intl !== undefined) {
              formatter = new Intl.DateTimeFormat(lang, {
                  weekday: 'short',
                  timeZone: 'UTC'
              });
          } else {
              formatter = {
                  format: function(date) {
                      return date.toUTCString().split(' ')[0].substring(0, 3)
                  }
              }
          }
          return Array.apply(null, Array(7)).map(function(_, i) {
              return formatter.format(new Date(Date.UTC(2014, 1, i + 2)));
          });
      }
  };

  var SCROLL_DURATION = 200;

  // Adapted from https://coderwall.com/p/hujlhg/smooth-scrolling-without-jquery
  function smooth_scroll_to(element, target, duration) {
      target = Math.round(target);
      duration = Math.round(duration);
      if (duration < 0) {
          return Promise.reject('bad duration');
      }
      if (duration === 0) {
          element.scrollTop = target;
          return Promise.resolve('no-duration');
      }

      var start_time = Date.now();
      var end_time = start_time + duration;

      var start_top = element.scrollTop;
      var distance = target - start_top;

      // based on http://en.wikipedia.org/wiki/Smoothstep
      var smooth_step = function(start, end, point) {
          if (point <= start) {
              return 0;
          }
          if (point >= end) {
              return 1;
          }
          var x = (point - start) / (end - start); // interpolation
          return x * x * (3 - 2 * x);
      }

      return new Promise(function(resolve, reject) {
          // This is to keep track of where the element's scrollTop is
          // supposed to be, based on what we're doing
          var previous_top = element.scrollTop;

          var timer = null;
          // This is like a think function from a game loop
          var scroll_frame = function() {
              /*
              // This logic is too fragile
              if(element.scrollTop != previous_top) {
                  window.clearInterval(timer);
                  reject('interrupted');
                  return;
              }
              */
              // set the scrollTop for this frame
              var now = Date.now();
              var point = smooth_step(start_time, end_time, now);
              var frameTop = Math.round(start_top + (distance * point));
              element.scrollTop = frameTop;

              // check if we're done!
              if (now >= end_time) {
                  window.clearInterval(timer);
                  resolve('done');
                  return;
              }

              // If we were supposed to scroll but didn't, then we
              // probably hit the limit, so consider it done; not
              // interrupted.
              if (element.scrollTop === previous_top && element.scrollTop !== frameTop) {
                  window.clearInterval(timer);
                  resolve('limit');
                  return;
              }
              previous_top = element.scrollTop;
          }

          // boostrap the animation process
          timer = setInterval(scroll_frame, 10);
      });
  }

  function clickFor(to, offset) {
      return function(evt) {
          var target = document.getElementById(to);
          if (target === undefined) {
              return true;
          }
          offset = offset || 0;
          var delta = getAbsoluteBoundingRect(target).top + offset;
          smooth_scroll_to(document.body, delta, SCROLL_DURATION).catch(function(e) {
              console.error(e);
          });
          evt.preventDefault();
          return false;
      }
  }

  var scrollNodes = [];

  function throttle(type, name, obj) {
      obj = obj || window;
      var running = false;
      var func = function() {
          if (running) {
              return;
          }
          running = true;
          requestAnimationFrame(function() {
              obj.dispatchEvent(new CustomEvent(name));
              running = false;
          });
      };
      obj.addEventListener(type, func);
  }

  function onScroll() {
      var pos = window.scrollY;
      scrollNodes.forEach(function(params) {
          var node = params[0];
          var current = params[1];
          var cls = params[2];
          var extents = params[4];

          var state = false;
          for (var i = 0; i < extents.length; i++) {
              var extent = extents[i];
              state = (pos > extent.start && pos < extent.end);
              if (state) {
                  break;
              }
          }

          if (state === current) {
              return;
          }
          params[1] = state;
          if (state) {
              node.classList.add(cls);
          } else {
              node.classList.remove(cls);
          }
      });
  }

  function getAbsoluteBoundingRect(el) {
      var doc = document,
          win = window,
          body = doc.body,

          // pageXOffset and pageYOffset work everywhere except IE <9.
          offsetX = win.pageXOffset !== undefined ? win.pageXOffset :
          (doc.documentElement || body.parentNode || body).scrollLeft,
          offsetY = win.pageYOffset !== undefined ? win.pageYOffset :
          (doc.documentElement || body.parentNode || body).scrollTop,

          rect = el.getBoundingClientRect();

      if (el !== body) {
          var parent = el.parentNode;

          // The element's rect will be affected by the scroll positions of
          // *all* of its scrollable parents, not just the window, so we have
          // to walk up the tree and collect every scroll offset. Good times.
          while (parent !== body) {
              offsetX += parent.scrollLeft;
              offsetY += parent.scrollTop;
              parent = parent.parentNode;
          }
      }

      return {
          bottom: rect.bottom + offsetY,
          height: rect.height,
          left: rect.left + offsetX,
          right: rect.right + offsetX,
          top: rect.top + offsetY,
          width: rect.width
      };
  }

  function updateRegions() {
      scrollNodes.forEach(function(params) {
          var target = params[0].getBoundingClientRect();
          var overlap = params[3];

          var nodes = document.querySelectorAll(overlap);
          var all = [];
          for (var i = 0; i < nodes.length; i++) {
              var node = nodes[i];
              var ext = getAbsoluteBoundingRect(node);
              all.push({
                  start: ext.top - target.height,
                  end: ext.bottom
              });
          }
          params[4] = all;
      });
  }

  var Scroll = {
      initSmooth: function initSmooth(selector, offset) {
          var nodes = document.querySelectorAll(selector);
          for (var i = 0; i < nodes.length; i++) {
              var node = nodes[i];
              var href = node.attributes.href;
              if (href === undefined || href.length === 0) {
                  continue;
              }
              var to = href.nodeValue.toString();
              if (to.substr(0, 1) !== '#') {
                  continue;
              }

              node.addEventListener('click', clickFor(to.substr(1), offset), false);
          }
      },
      toggleClass: function toggleClass(selector, cls, overlap) {
          var nodes = document.querySelectorAll(selector);
          if (nodes.length > 0) {
              window.addEventListener('optimizedResize', updateRegions);
              window.addEventListener('optimizedScroll', onScroll);
          }
          for (var i = 0; i < nodes.length; i++) {
              var node = nodes[i];
              var param = [node, null, cls, overlap, []];

              // check for this node
              var found = false;
              for (var ii = 0; i < scrollNodes.length; i++) {
                  if (scrollNodes[ii][0] == node) {
                      scrollNodes[ii] = param;
                      found = true;
                      break;
                  }
              }
              if (!found) {
                  scrollNodes.push(param);
              }
          }
          updateRegions();
          onScroll();
      },
      updateRegions: updateRegions
  };

  throttle('scroll', 'optimizedScroll');
  throttle('resize', 'optimizedResize');

  var Timing = {
    now: function now() {
      var performance = window.performance;
      if (performance === undefined) {
        this.now = function() {
          return new Date().getTime();
        }
      } else {
        if (performance.now) {
          this.now = function() { return performance.now();}
        } else if (performance.webkitNow) {
          this.now = function() { return performance.webkitNow();}
        } else if (performance.msNow) {
          this.now = function() { return performance.msNow();}
        } else if (performance.oNow) {
          this.now = function() { return performance.oNow();}
        } else if (performance.mozNow) {
          this.now = function() { return performance.mozNow();}
        } else {
          throw new Error('unknown window.performance impl');
        }
      }

      return this.now();
    }
  };

  var DB = function DB(treo, max) {
      if ( max === void 0 ) max = 5;

      this.treo = treo;
      this.tm = {};
      this.count = 0;
      this.outstanding = [];
      this.runningTotal = 0;
      this.puts = 0;
      this.max = max
      if (max) {
          this.max = max;
      }
  };

  DB.prototype.countQueue = function countQueue () {
      return this.puts;
  };

  DB.prototype.countTransactionsQueue = function countTransactionsQueue () {
      return this.outstanding.length;
  };

  DB.prototype.countTransactions = function countTransactions () {
      return this.count;
  };

  DB.prototype.runningTransactionTotal = function runningTransactionTotal () {
      return this.runningTotal;
  };

  DB.prototype.shiftq = function shiftq (store, q, name, on) {
      if (on === undefined) {
          on = 1;
      }
      var self = this;
      var e = q.shift();
      if (e) {
          var req = store.put(e.v, e.k);
          this.puts = this.puts - 1;
          req.onsuccess = function() {
              // Technically the transaction could still be aborted/fail so slightly wrong
              e.r();
              self.shiftq(store, q, name, (on + 1));
          };
          req.onerror = function(event) {
              e.j(event);
          };
      } else {
          // done, transaction will close
          // console.log('Drained', name, 'on', on);
          this.tm[name] = null;
      }
  };

  DB.prototype.gate = function gate (cb) {
      var self = this;

      function invoke() {
          var called = false;
          self.count = self.count + 1;
          try {
              self.runningTotal = self.runningTotal + 1;
              cb(function() {
                  if (!called) {
                      called = true;
                      self.count = self.count - 1;
                  }
                  var next = self.outstanding.shift();
                  if (next) {
                      self.gate(next);
                  }
              });
          } catch (e) {
              if (!called) {
                  called = true;
                  self.count = self.count - 1;
              }
              throw e;
          }
      }

      if (this.count >= this.max) {
          // console.log(this.count, 'transactions reached, moved to the q');
          this.outstanding.push(cb);
      } else {
          invoke();
      }
  };

  DB.prototype.put = function put (store, val, optionalKey) {
      var self = this;
      var treo = this.treo;
      var tm = this.tm;
      var q = tm[store];
      this.puts = this.puts + 1;
      return new Promise(function(resolve, reject) {
          var entry = {
              v: val,
              r: resolve,
              j: reject,
              k: optionalKey
          };
          if (q == null) {
              q = [entry];
              tm[store] = q;

              self.gate(function(release) {
                  treo.transaction('readwrite', [store], function(err, tr) {
                      if (err) {
                          release();
                          q.forEach(function(e) {
                              e.j();
                          });
                          return;
                      }

                      tr.oncomplete = function() {
                          release();
                          tm[store] = null;
                      };

                      tr.onerror = function(event) {
                          q.forEach(function(e) {
                              e.j();
                          });
                          release();
                          tm[store] = null;
                      };

                      // start the drain
                      self.shiftq(tr.objectStore(store), q, store);
                  });
              });
          } else {
              q.push(entry);
          }
      });
  };

  var TreoWriter = {
      wrap: function wrap(treo, max) {
          return new DB(treo, max);
      }
  };

  var style = document.createElement("style");
  document.head.appendChild(style);
  var sheet = style.sheet;

  function updateRange(input, index) {
      var min = input.min || 0;
      var max = input.max || 100;

      var v = Math.ceil(((input.value - min) / (max - min)) * 100);
      try {
          sheet.deleteRule(index);
      } catch (e) {}
      sheet.addRule('input[type=range].rs-index-' + index + '::-webkit-slider-runnable-track', 'background-size:' + v + '% 100%', index);
  }

  var Sliders = {
      initAllRanges: function initAllRanges() {
          var r = document.querySelectorAll('input[type=range]');
          var loop = function ( i ) {
              var input = r[i];

              input.className += " rs-index-" + i;
              updateRange(input, i);
              (function(idx) {
                  input.addEventListener('input', function() {
                      updateRange(this, idx);
                  });
              })(i);
          };

          for (var i = 0; i < r.length; i++) loop( i );
      },

      setValue: function setValue(control, value) {
          control.value = value;
          var r = document.querySelectorAll('input[type=range]');
          for (var i = 0; i < r.length; i++) {
              if (r[i] === control) {
                  updateRange(control, i);
              }
          }
      }
  };

  var StyleSwitcher = {
      use: function use(title) {
          var themes = document.getElementsByTagName('link');
          for (var idx = 0; idx < themes.length; idx++) {
              var theme = themes[idx];

              if ((theme.rel.indexOf('stylesheet') != -1) && theme.title) {
                  theme.disabled = true;
                  if (theme.title == title) {
                      theme.disabled = false;
                  }
              }
          }
      }
  }

  // Smooth some data with a given window size.
  function smooth(d, w) {
      var result = [];
      for (var i = 0, l = d.length; i < l; ++i) {
          var mn = Math.max(0, i - 5 * w),
              mx = Math.min(d.length - 1, i + 5 * w),
              s = 0.0;
          result[i] = 0.0;
          for (var j = mn; j < mx; ++j) {
              var wd = Math.exp(-0.5 * (i - j) * (i - j) / w / w);
              result[i] += wd * d[j];
              s += wd;
          }
          result[i] /= s;
      }
      return result;
  }

  var Xkcd = {
  	wiggle: function wiggle(perturbation, magnitude, fx, fy) {
  		if (perturbation === undefined) {
  			perturbation = 0.93;
  		}

          if (magnitude === undefined) {
  			magnitude = 0.003;
  		}

          if (fx === undefined) {
  			fx = 500;
  		}

          if (fy === undefined) {
  			fy = 300;
  		}

          // XKCD-style line interpolation. Roughly based on:
          // jakevdp.github.com/blog/2012/10/07/xkcd-style-plots-in-matplotlib
          return function (points) {
              // Scale the data.
              var scaled = points.map(function (p) {
                  return [p[0] / fx, p[1] / fy];
              });

              // Compute the distance along the path using a map-reduce.
              var dists = scaled.map(function (d, i) {
                  if (i == 0) return 0.0;
                  var dx = d[0] - scaled[i - 1][0],
                      dy = d[1] - scaled[i - 1][1];
                  return Math.sqrt(dx * dx + dy * dy);
              }),
                  dist = dists.reduce(function (curr, d) { return d + curr; }, 0.0);

              // Choose the number of interpolation points based on this distance.
              var N = Math.round(200 * dist);

              // Re-sample the line.
              var resampled = [];
              dists.map(function (d, i) {
                  if (i == 0) return;
                  var n = Math.max(3, Math.round(d / dist * N)),
                      spline = d3.interpolate(scaled[i - 1][1], scaled[i][1]),
                      delta = (scaled[i][0] - scaled[i - 1][0]) / (n - 1);
                  for (var j = 0, x = scaled[i - 1][0]; j < n; ++j, x += delta)
                      resampled.push([x, spline(j / (n - 1))]);
              });

              // Compute the gradients.
              var gradients = resampled.map(function (a, i, d) {
                  if (i == 0) return [d[1][0] - d[0][0], d[1][1] - d[0][1]];
                  if (i == resampled.length - 1)
                      return [d[i][0] - d[i - 1][0], d[i][1] - d[i - 1][1]];
                  return [0.5 * (d[i + 1][0] - d[i - 1][0]),
                          0.5 * (d[i + 1][1] - d[i - 1][1])];
              });

              // Normalize the gradient vectors to be unit vectors.
              gradients = gradients.map(function (d) {
                  var len = Math.sqrt(d[0] * d[0] + d[1] * d[1]);
                  if (len === 0) return [0, 0];
                  return [d[0] / len, d[1] / len];
              });

              // Generate some perturbations.
              var perturbations = smooth(resampled.map(d3.random.normal(0.0, perturbation)), 3);

              // Add in the perturbations and re-scale the re-sampled curve.
              var result = resampled.map(function (d, i) {
                  var p = perturbations[i],
                      g = gradients[i];

                  return [((d[0] + magnitude * g[1] * p) * fx).toFixed(6),
                          ((d[1] - magnitude * g[0] * p) * fy).toFixed(6)];
              });

              return result.join("L");
          }
  	}
  };

  var disableSelectionStyle = "\n  * {\n    -webkit-touch-callout: none;\n    -webkit-user-select: none;\n    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  }\n";

  function cssDisableSelection() {
    var node = document.createElement('style');
    node.innerHTML = disableSelectionStyle;
    document.body.appendChild(node);
  }

  exports.FeatureDetection = FeatureDetection;
  exports.ColorTools = ColorTools;
  exports.Lang = Lang;
  exports.Scroll = Scroll;
  exports.Timing = Timing;
  exports.TreoWriter = TreoWriter;
  exports.Sliders = Sliders;
  exports.StyleSwitcher = StyleSwitcher;
  exports.Xkcd = Xkcd;
  exports.cssDisableSelection = cssDisableSelection;

  Object.defineProperty(exports, '__esModule', { value: true });

}));