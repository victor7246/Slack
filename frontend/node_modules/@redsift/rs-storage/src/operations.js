import loglevel from 'loglevel';
import treo from 'treo';

var logger = loglevel.getLogger('RSStorage:operations');
logger.setLevel('warn');

// Email msg buckets
export const EMAIL_BUCKETS = ['_email.id', '_email.tid'];
// Message Db schema
const MSG_DB_VERSIONED_SCHEMA = [
  // version 1
  [
    { name: '_id.list', indexes: ['sift.guid'] },
    { name: '_tid.list', indexes: ['sift.guid'] }
  ],
  // version 2
  [
    { name: '_email.id', indexes: ['sift.guid'] },
    { name: '_email.tid', indexes: ['sift.guid'] },
    { name: '_id.list', drop: true },
    { name: '_tid.list', drop: true }
  ]
];
// Sync DB schema
const SYNC_DB_SCHEMA = [
  { name: 'events', indexes: ['value.sift.guid'] },
  { name: 'admin' }];
// Client DB schema
const CLIENT_DB_SCHEMA = [
  { name: 'tour'},
  { name: 'spm' },
  { name: 'auth' }];

/*****************************************************************
 * Operations (alphabetically ordered)
 *****************************************************************/
// Create Db
export function opCreateDb(dbInfo) {
  logger.trace('[opCreateDb]: ', dbInfo);
  let dbs = {};
  switch (dbInfo.type) {
    case 'MSG':
      dbs.msg = treo('rs_msg_db-' + dbInfo.accountGuid, _getVersionedTreoSchema(MSG_DB_VERSIONED_SCHEMA));
      break;
    case 'SIFT':
      if (!dbInfo.siftGuid) {
        throw new Error('[opCreateDb]: dbInfo.siftGuid undefined');
      }
      logger.trace('[opCreateDb]: creating SIFT db');
      var schema = _getTreoSchema(dbInfo.schema, true);
      // Add user and redsift stores to sift db.
      schema = schema.addStore('_user.default').addStore('_redsift');
      dbs.db = treo(dbInfo.siftGuid + '-' + dbInfo.accountGuid, schema);
      dbs.msg = treo('rs_msg_db-' + dbInfo.accountGuid, _getVersionedTreoSchema(MSG_DB_VERSIONED_SCHEMA));
      break;
    case 'SYNC':
      logger.trace('[opCreateDb]: creating SYNC db');
      dbs.db = treo('rs_sync_log-' + dbInfo.accountGuid, _getTreoSchema(SYNC_DB_SCHEMA));
      break;
    case 'CLIENT':
      dbs.db = treo('rs_client_db-' + dbInfo.clientName, _getTreoSchema(CLIENT_DB_SCHEMA));
      break;
    default:
      throw new Error('[opCreateDb]: unsupported db type: ' + dbInfo.type);
  }
  return dbs;
}

// Cursor
export function opCursor(db, params, done) {
  logger.trace('[opCursor]', params);
  if (!params.bucket) {
    throw new Error('[opCursor: params.bucket undefined');
  }
  else {
    var bucket = db.store(params.bucket);
    bucket.cursor({ iterator: params.iterator }, done);
  }
}

// Delete database
export function opDeleteDatabase(db) {
  logger.trace('[opDeleteDatabase]');
  return new Promise((resolve, reject) => {
    db.drop((err) => {
      if (!err) {
        resolve();
      }
      else {
        reject(err);
      }
    });
  });
}

// Del
export function opDel(dbs, params, siftGuid) {
  logger.trace('[opDel]: ', params, siftGuid);
  if (!params.bucket) {
    return Promise.reject('[opDel]: params.bucket undefined');
  }
  if (!params.keys || params.keys.length === 0) {
    logger.trace('[opDel]: params.keys undefined');
    return Promise.resolve();
  }
  if (EMAIL_BUCKETS.indexOf(params.bucket) !== -1) {
    var keys = params.keys.map((k) => {
      return siftGuid + '/' + k;
    });
    return _batchDelete(dbs.msg, { bucket: params.bucket, keys: keys });
  }
  return _batchDelete(dbs.db, params);
}

// Get
export function opGet(dbs, params, siftGuid) {
  logger.trace('[opGet]: ', params);
  if (!params.bucket) {
    return Promise.reject('[opGet]: params.bucket undefined');
  }
  if (!params.keys) {
    return Promise.reject('[opGet]: param.keys undefined');
  }
  if(params.keys.length === 0) {
    return Promise.resolve([]);
  }
  if (EMAIL_BUCKETS.indexOf(params.bucket) !== -1) {
    var keys = params.keys.map((k) => {
      return siftGuid + '/' + k;
    });
    return _findIn(dbs.msg, { bucket: params.bucket, keys: keys }).then((result) => {
      return result.map((r) => {
        return { key: r.key.split('/')[1], value: r.value };
      });
    });
  }
  return _findIn(dbs.db, params);
}

// Get All
export function opGetAll(dbs, params, siftGuid) {
  logger.trace('[opGetAll]: ', params, siftGuid);
  if (!params.bucket) {
    return Promise.reject('[opGetAll]: params.bucket undefined');
  }
  if (EMAIL_BUCKETS.indexOf(params.bucket) !== -1) {
    return _getAll(dbs.msg, { bucket: params.bucket, index: 'sift.guid', range: siftGuid }, true)
      .then(result =>
        result.map(r => ({ key: r.key.split('/')[1], value: r.value }))
      );
  }
  return _getAll(dbs.db, params, true);
}

// Get All Keys
export function opGetAllKeys(dbs, params, siftGuid) {
  logger.trace('[opGetAllKeys]: ', params, siftGuid);
  if (!params.bucket) {
    return Promise.reject('[opGetAllKeys]: params.bucket undefined');
  }
  if (EMAIL_BUCKETS.indexOf(params.bucket) !== -1) {
    return _getAll(dbs.msg, { bucket: params.bucket, index: 'sift.guid', range: siftGuid }, false)
      .then(result => result.map(r => r.key.split('/')[1]));
  }
  return _getAll(dbs.db, params, false);
}

// Get Index
export function opGetIndex(dbs, params, siftGuid) {
  logger.trace('[opGetIndex]: ', params, siftGuid);
  if (!params.bucket) {
    return Promise.reject('[opGetIndex]:params.bucket undefined');
  }
  if (EMAIL_BUCKETS.indexOf(params.bucket) !== -1) {
    return _getAll(dbs.msg, { bucket: params.bucket, index: 'sift.guid', range: siftGuid }, true).then((result) => {
      return result.map((r) => {
        return { key: r.key.split('/')[1], value: r.value };
      });
    });
  }
  if (!params.index) {
    return Promise.reject('[opGetIndex]:params.index undefined');
  }
  return _getAll(dbs.db, params, true);
}

// Get Index Keys
export function opGetIndexKeys(dbs, params, siftGuid) {
  logger.trace('[opGetIndexKeys]: ', params, siftGuid);
  if (!params.bucket) {
    return Promise.reject('[opGetIndexKeys]: params.bucket undefined');
  }
  if (EMAIL_BUCKETS.indexOf(params.bucket) !== -1) {
    return _getAll(dbs.msg, { bucket: params.bucket, index: 'sift.guid', range: siftGuid }, false).then((result) => {
      return result.map((r) => {
        return { key: r.key.split('/')[1], value: r.value };
      });
    });
  }
  if (!params.index) {
    return Promise.reject('[opGetIndexKeys]: params.index undefined');
  }
  return _getAll(dbs.db, params, false);
}

// Get With Index
export function opGetWithIndex(dbs, params, siftGuid) {
  logger.trace('[opGetWithIndex]: ', params, siftGuid);
  if (!params.bucket) {
    return Promise.reject('[opGetWithIndex]:params.bucket undefined');
  }
  if (!params.keys) {
    return Promise.reject('[opGetWithIndex]:params.keys undefined');
  }
  if (EMAIL_BUCKETS.indexOf(params.bucket) !== -1) {
    var keys = params.keys.map((k) => {
      return siftGuid + '/' + k;
    });
    return _getWithIndexRange(dbs.msg, { bucket: params.bucket, keys: keys, index: 'sift.guid', range: siftGuid }).then((result) => {
      return result.map((r) => {
        return { key: r.key.split('/')[1], value: r.value };
      });
    });
  }
  if (!params.index) {
    return Promise.reject('[opGetWithIndex]:params.index undefined');
  }
  if (!params.range) {
    return Promise.reject('[opGetWithIndex]:params.range undefined');
  }
  return _getWithIndexRange(dbs.db, params);
}

// Put
export function opPut(dbs, params, raw, siftGuid) {
  logger.trace('[opPut]: ', params, raw, siftGuid);
  var db = dbs.db;
  if (!params.bucket) {
    return Promise.reject('[opPut]: params.bucket undefined');
  }
  if (!params.kvs || params.kvs.length === 0) {
    logger.warn('[opPut]: params.kvs undefined');
    return Promise.resolve();
  }
  var kvs = params.kvs;
  if (!raw) {
    // Wrap value into a {value: object}
    kvs = kvs.map((kv) => {
      return { key: kv.key, value: { value: kv.value } };
    });
  }
  if (EMAIL_BUCKETS.indexOf(params.bucket) !== -1) {
    db = dbs.msg;
    var kvs = kvs.map((kv) => {
      return { key: siftGuid + '/' + kv.key, value: kv.value };
    });
  }
  return _batchPut(db, { bucket: params.bucket, kvs: kvs }, raw);
}

/*****************************************************************
 * Internal functions
 *****************************************************************/

// define db schema
function _getTreoSchema(stores, sift) {
  logger.trace('[_getTreoSchema]: ', stores, sift);
  var schema = treo.schema().version(1);
  stores.forEach((os) => {
    if (!(sift && (EMAIL_BUCKETS.indexOf(os.name) !== -1))) {
      if (os.keypath) {
        schema = schema.addStore(os.name, { key: os.keypath });
      }
      else {
        schema = schema.addStore(os.name);
      }
      if (os.indexes) {
        os.indexes.forEach((idx) => {
          schema = schema.addIndex(idx, 'twoI.' + idx, { unique: false });
        });
      }
    }
  });
  return schema;
}

// versioned db schema
function _getVersionedTreoSchema(versions, sift) {
  logger.trace('[_getVersionedTreoSchema]: ', versions, sift);
  var schema = treo.schema();
  versions.forEach((stores, i) => {
    schema = schema.version(i + 1);
    stores.forEach((os) => {
      if (!(sift && (EMAIL_BUCKETS.indexOf(os.name) !== -1))) {
        if (os.drop) {
          logger.trace('[_getVersionedTreoSchema]: dropping store: ', os.name);
          schema = schema.dropStore(os.name);
        }
        else if (os.keypath) {
          schema = schema.addStore(os.name, { key: os.keypath });
        }
        else {
          schema = schema.addStore(os.name);
        }
        if (os.indexes) {
          os.indexes.forEach((idx) => {
            if (os.drop) {
              logger.trace('[_getVersionedTreoSchema]: dropping store/index: ' + os.name + '/' + idx);
              schema = schema.dropIndex(idx);
            }
            else {
              schema = schema.addIndex(idx, idx, { unique: false });
            }
          });
        }
      }
    });
  });
  return schema;
}

// Batch deletion supports numeric keys
function _batchDelete(db, params) {
  logger.trace('[_batchDelete]: ', params);
  return new Promise((resolve, reject) => {
    db.transaction('readwrite', [params.bucket], (err, tr) => {
      if (err) { return reject(err); }
      var store = tr.objectStore(params.bucket);
      var current = 0;
      var next = () => {
        if (current >= params.keys.length) { return; }
        var currentKey = params.keys[current];
        var req;
        req = store.delete(currentKey);
        req.onerror = reject;
        req.onsuccess = next;
        current += 1;
      };
      tr.onerror = tr.onabort = reject;
      tr.oncomplete = () => { resolve(); };
      next();
    });
  });
}

function _batchPut(db, params) {
  logger.trace('[_batchPut]: ', params);
  return new Promise((resolve, reject) => {
    var count = params.kvs.length;
    db.transaction('readwrite', [params.bucket], (err, tr) => {
      if (err) { return reject(err); }
      var store = tr.objectStore(params.bucket);
      var current = 0;
      var next = () => {
        if (current >= count) { return; }
        logger.trace('[_batchPut: put: ', params.kvs[current]);
        var req;
        req = store.put(params.kvs[current].value, params.kvs[current].key);
        req.onerror = reject;
        req.onsuccess = next;
        current += 1;
      };
      tr.onerror = tr.onabort = reject;
      tr.oncomplete = () => { resolve(); };
      next();
    });
  });
}

function _getWithIndexRange(db, params) {
  logger.trace('[_getWithIndexRange]: ', params);
  return new Promise((resolve, reject) => {
    var store = db.store(params.bucket);
    var result = [];
    var found = 0;
    var iterator = (cursor) => {
      var ki = params.keys.indexOf(cursor.primaryKey);
      if (ki !== -1) {
        logger.trace('[found key: ', cursor.primaryKey);
        result[ki].value = cursor.value.value;
        found++;
      }
      if (found === params.keys.length) {
        return done();
      }
      cursor.continue();
    };
    var done = (err) => {
      logger.trace('[_getWithIndexRange: result: ', result);
      err ? reject(err) : resolve(result);
    };
    params.keys.forEach((k) => {
      result.push({ key: k, value: undefined });
    });
    store.cursor({ index: params.index, range: params.range, iterator: iterator }, done);
  });
}

function _findIn(db, params) {
  logger.trace('[_findIn]: ', params);
  return new Promise((resolve, reject) => {
    var store = db.store(params.bucket);
    var result = [];
    var current = 0;
    var iterator = (cursor) => {
      logger.trace('[_findIn]: iterator: ', cursor);
      if (cursor.key > sKeys[current]) {
        logger.trace('[_findIn]: cursor ahead: ', cursor.key, sKeys[current]);
        while (cursor.key > sKeys[current] && current < sKeys.length) {
          current += 1;
          logger.trace('[_findIn]: moving to next key: ', cursor.key, sKeys[current]);
        }
        if (current > sKeys.length) {
          logger.trace('[_findIn]: exhausted keys. done.');
          return done();
        }
      }
      if (cursor.key === sKeys[current]) {
        logger.trace('[_findIn]: found key: ', cursor.key, cursor.value);
        result[params.keys.indexOf(sKeys[current])] = { key: cursor.key, value: cursor.value.value };
        current += 1;
        (current < sKeys.length) ? cursor.continue(sKeys[current]) : done();
      }
      else {
        logger.trace('[_findIn]: continuing to next key: ', sKeys[current]);
        cursor.continue(sKeys[current]); // go to next key
      }
    };
    var done = (err) => {
      logger.trace('[findIn]: result: ', result);
      err ? reject(err) : resolve(result);
    };
    var sKeys = params.keys.slice();
    sKeys = sKeys.sort(treo.cmp);
    logger.trace('[findIn: sorted keys: ', sKeys);
    params.keys.forEach((k) => {
      result.push({ key: k, value: undefined });
    });
    store.cursor({ iterator: iterator }, done);
  });
}

function _getAll(db, params, loadValue) {
  logger.trace('[_getAll]: ', params, loadValue);
  return new Promise((resolve, reject) => {
    var result = [];
    var keys = [];
    var store = db.store(params.bucket);
    var iterator = (cursor) => {
      var kv = { key: cursor.primaryKey };
      logger.trace('[_getAll]: cursor', cursor);
      if (loadValue) {
        kv.value = cursor.value.value;
      }
      if (params.index) {
        kv.index = cursor.key;
      }
      result.push(kv);
      keys.push(cursor.primaryKey);
      cursor.continue();
    };
    var opts = { iterator: iterator };
    if (params.index) {
      opts.index = params.index;
    }
    if (params.range) {
      opts.range = params.range;
    }
    store.cursor(opts, (err) => {
      if (err) {
        reject(err);
      }
      else {
        if (!params.index && !params.range && !loadValue) {
          logger.trace('[_getAll]: resolving: ', keys);
          resolve(keys);
        }
        else {
          logger.trace('[_getAll]: resolving: ', result);
          resolve(result);
        }
      }
    });
  });
}